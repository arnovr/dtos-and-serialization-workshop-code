# Serialized output for clients

Consider the domain object

## Solution 1: Serialize domain objects

Advantages:

- Seems like the most easy thing to do.

Disadvantages:

- Breaks object encapsulation (exposes implementation details, data types and structures).
- Couples your clients to the intricate details of your domain model. This prevents you from making "BC-breaking changes" to your domain model.
- Forces the client to have more knowledge than it should.

## Solution 2: Serialize intermediate objects based on domain objects

Advantages:

- Gives you full control over the way the data gets rendered.
- Gives you the option (or maybe forces you) to tailor the data to specific use cases.
- Works well with CQRS.

### Option A: Let the domain object create DTOs

Advantages:

- The domain object itself has all the required knowledge and has access to all the data it needs.

Disadvantages:

- Different use cases for reading data will cause new factory methods to be added to the domain model, which might feel like pollution. Might feel like a violation of the *Single Responsibility Principle*.

### Option B: Let a dedicated factory create DTOs

Advantages:

- The *write* model doesn't contain code that is only needed by the *read* side of the application.
- You can properly inject dependencies instead of creating them when needed or relying on them in a static fashion.

Disadvantage:

- The *write* model will need getters to allow the factory to reach into the object (can be overcome using closure binding!).
